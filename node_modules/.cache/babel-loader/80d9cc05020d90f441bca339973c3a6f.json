{"ast":null,"code":"\"use strict\";\n\nvar _regeneratorRuntime = require(\"/Users/aalasseh/Desktop/srFECogngy/node_modules/@babel/runtime/regenerator/index.js\");\n\nvar _createForOfIteratorHelper = require(\"/Users/aalasseh/Desktop/srFECogngy/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js\").default;\n\nvar _classCallCheck = require(\"/Users/aalasseh/Desktop/srFECogngy/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\n\nvar _createClass = require(\"/Users/aalasseh/Desktop/srFECogngy/node_modules/@babel/runtime/helpers/createClass.js\").default;\n\nvar _inherits = require(\"/Users/aalasseh/Desktop/srFECogngy/node_modules/@babel/runtime/helpers/inherits.js\").default;\n\nvar _createSuper = require(\"/Users/aalasseh/Desktop/srFECogngy/node_modules/@babel/runtime/helpers/createSuper.js\").default;\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : new P(function (resolve) {\n        resolve(result.value);\n      }).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar events_1 = require(\"events\");\n\nvar SocketIOClient = require(\"socket.io-client\");\n\nvar uuid_1 = require(\"uuid\");\n\nvar compatibility_1 = require(\"./helper/compatibility\");\n\nvar SocketClient = /*#__PURE__*/function (_events_1$EventEmitte) {\n  _inherits(SocketClient, _events_1$EventEmitte);\n\n  var _super = _createSuper(SocketClient);\n\n  function SocketClient(socketUrl, socketToken, options) {\n    var _this;\n\n    _classCallCheck(this, SocketClient);\n\n    _this = _super.call(this);\n    _this.messageBuffer = [];\n    _this.socketUrl = socketUrl;\n    _this.socketURLToken = socketToken;\n    _this.socketOptions = SocketClient.completeSocketOptions(options);\n    _this.reconnectCounter = 0;\n\n    _this.updateLastUsed();\n\n    return _this;\n  }\n\n  _createClass(SocketClient, [{\n    key: \"resetReconnectionCounter\",\n    value: function resetReconnectionCounter() {\n      this.reconnectCounter = 0;\n    }\n  }, {\n    key: \"registerReconnectionAttempt\",\n    value: function registerReconnectionAttempt() {\n      this.reconnectCounter++;\n      console.log(\"[SocketClient] Trying to reconnect\");\n\n      if (this.shouldStopReconnecting()) {\n        console.log(\"[SocketClient] Reconnection attempts limit reached. Giving up.\");\n        this.emit(\"socket/error\", {\n          type: \"RECONNECTION_LIMIT\"\n        });\n      }\n    }\n  }, {\n    key: \"shouldStopReconnecting\",\n    value: function shouldStopReconnecting() {\n      var reconnectionLimit = this.socketOptions.reconnectionLimit;\n      return reconnectionLimit !== 0 && reconnectionLimit <= this.reconnectCounter;\n    }\n  }, {\n    key: \"flushMessageBuffer\",\n    value: function flushMessageBuffer() {\n      if (this.messageBuffer.length > 0) {\n        if (this.connected) {\n          console.log(\"[SocketClient] Starting to send your buffered messages...\");\n\n          var _iterator = _createForOfIteratorHelper(this.messageBuffer),\n              _step;\n\n          try {\n            for (_iterator.s(); !(_step = _iterator.n()).done;) {\n              var msg = _step.value;\n              this.sendMessage(msg.text, msg.data);\n            }\n          } catch (err) {\n            _iterator.e(err);\n          } finally {\n            _iterator.f();\n          }\n\n          console.log(\"[SocketClient] Finished sending \".concat(this.messageBuffer.length, \" buffered messages.\"));\n          this.messageBuffer = [];\n        } else {\n          console.log('[SocketClient] Could not send your buffered messages because we are not connected');\n        }\n      }\n    }\n  }, {\n    key: \"setupReconnectInterval\",\n    value: function setupReconnectInterval() {\n      var _this2 = this;\n\n      if (!this.socketReconnectInterval) {\n        this.socketReconnectInterval = setInterval(function () {\n          return __awaiter(_this2, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n            var isReconnect;\n            return _regeneratorRuntime.wrap(function _callee$(_context) {\n              while (1) {\n                switch (_context.prev = _context.next) {\n                  case 0:\n                    if (!(!this.connected && !this.shouldStopReconnecting())) {\n                      _context.next = 13;\n                      break;\n                    }\n\n                    this.registerReconnectionAttempt();\n                    _context.prev = 2;\n                    isReconnect = true;\n                    _context.next = 6;\n                    return this.connect(isReconnect);\n\n                  case 6:\n                    console.log(\"[SocketClient] Successfully reconnected.\");\n                    _context.next = 12;\n                    break;\n\n                  case 9:\n                    _context.prev = 9;\n                    _context.t0 = _context[\"catch\"](2);\n                    console.error(\"[SocketClient] Failed to reconnect, error was: \".concat(JSON.stringify(_context.t0)));\n\n                  case 12:\n                    ;\n\n                  case 13:\n                  case \"end\":\n                    return _context.stop();\n                }\n              }\n            }, _callee, this, [[2, 9]]);\n          }));\n        }, this.socketOptions.interval);\n      }\n    }\n  }, {\n    key: \"updateLastUsed\",\n    value: function updateLastUsed() {\n      this.lastUsed = Date.now();\n    }\n  }, {\n    key: \"connected\",\n    get: function get() {\n      if (!this.socket) return false;\n      return this.socket.connected;\n    }\n  }, {\n    key: \"expired\",\n    get: function get() {\n      if (this.socketOptions.expiresIn === null) return false;\n      return Date.now() - this.lastUsed > this.socketOptions.expiresIn;\n    }\n  }, {\n    key: \"connect\",\n    value: function connect() {\n      var isReconnect = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {\n        var _this3 = this;\n\n        var parsedUrl, path, connectOptions, socket;\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                parsedUrl = new URL(this.socketUrl);\n                path = parsedUrl.pathname && parsedUrl.pathname !== \"/\" ? parsedUrl.pathname + \"/socket.io\" : null;\n                connectOptions = {\n                  path: path,\n                  reconnection: false,\n                  upgrade: true,\n                  transports: [\"polling\", \"websocket\"]\n                };\n                /**\n                 * If websockets are forced or disabled,\n                 * change the transport and upgrade flags accordingly.\n                 *\n                 * In case both options are provided, forcing websockets\n                 * wins over disabling websockets.\n                 */\n\n                if (this.socketOptions.forceWebsockets) {\n                  connectOptions.transports = [\"websocket\"];\n                } else if (this.socketOptions.disableWebsockets) {\n                  connectOptions.transports = [\"polling\"];\n                  connectOptions.upgrade = false;\n                }\n                /**\n                 * Identify this endpoint to the endpoint for session-to-socket mapping.\n                 * Without this, the backend cannot \"take first steps\" because it can't\n                 * reach the client!\n                 */\n\n\n                connectOptions[\"query\"] = {\n                  sessionId: encodeURIComponent(this.socketOptions.sessionId),\n                  urlToken: encodeURIComponent(this.socketURLToken),\n                  userId: encodeURIComponent(this.socketOptions.userId)\n                };\n                socket = SocketIOClient.connect(parsedUrl.origin, connectOptions); // forward Socket.IO events\n\n                ['connect', 'connect_error', 'connect_timeout', 'error', 'disconnect', 'reconnect', 'reconnect_attempt', 'reconnecting', 'reconnect_error', 'reconnect_failed', 'ping', 'pong'].forEach(function (eventName) {\n                  socket.on(eventName, function (e) {\n                    _this3.emit(\"socket/\".concat(eventName), e);\n                  });\n                }); // pass through basic events\n\n                socket.on(\"exception\", function (error) {\n                  return _this3.emit('exception', error);\n                });\n                socket.on(\"typingStatus\", function (payload) {\n                  return _this3.emit('typingStatus', payload);\n                });\n                /**\n                 * Heads up!\n                 *\n                 * On v3 environments, we're publishing the \"finalPing\" as an \"output\" event with \"type: finalPing\",\n                 * on v4 environments, we're directly publishing the \"finalPing\" as a \"finalPing\" event!\n                 */\n\n                socket.on(\"finalPing\", function (reply) {\n                  return _this3.emit('finalPing', reply);\n                }); // decide positive / negative outcome of output based on content\n\n                socket.on(\"output\", function (reply) {\n                  if (reply && reply.type === \"error\") {\n                    return _this3.emit('error', reply.data.error);\n                  }\n\n                  if (reply && reply.type === \"output\") {\n                    var output = reply.data;\n\n                    _this3.emit('output', output);\n                  }\n\n                  if (reply && reply.type === \"finalPing\") {\n                    _this3.emit('finalPing', reply.data);\n                  }\n                }); // return success based on connection status\n\n                return _context2.abrupt(\"return\", new Promise(function (resolve, reject) {\n                  socket.on(\"connect_error\", function () {\n                    return reject(new Error(\"[SocketClient] Error connecting\"));\n                  });\n                  socket.on(\"connect_timeout\", function () {\n                    return reject(new Error(\"[SocketClient] Error connecting\"));\n                  });\n                  socket.on(\"connect\", function () {\n                    console.log(\"[SocketClient] connection established\");\n                    _this3.socket = socket;\n\n                    _this3.flushMessageBuffer(); // if configured, initialize automatic reconnect attempts\n\n\n                    // if configured, initialize automatic reconnect attempts\n                    if (_this3.socketOptions.reconnection) _this3.setupReconnectInterval();\n                    resolve(_this3);\n                  });\n                }));\n\n              case 12:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n    }\n  }, {\n    key: \"disconnect\",\n    value: function disconnect() {\n      clearInterval(this.socketReconnectInterval);\n      this.socketReconnectInterval = null;\n\n      if (this.socket) {\n        this.socket.disconnect();\n        this.socket = null;\n      }\n\n      return this;\n    }\n  }, {\n    key: \"sendMessage\",\n    value: function sendMessage(text, data) {\n      if (this.connected) {\n        this.resetReconnectionCounter();\n        this.updateLastUsed();\n        /* Send the processInput event to the endpoint */\n\n        this.socket.emit(\"processInput\", {\n          URLToken: this.socketURLToken,\n          userId: this.socketOptions.userId,\n          sessionId: this.socketOptions.sessionId,\n          channel: this.socketOptions.channel,\n          source: \"device\",\n          passthroughIP: this.socketOptions.passthroughIP,\n          resetFlow: !!this.socketOptions.resetFlow,\n          text: text,\n          data: data\n        });\n      } else {\n        // we currently have no connection - could be the case that we lost connection\n        // e.g. because of a server restart of the AI-server. Buffer all incoming\n        // messages - they will be send when the connection was re-established\n        this.messageBuffer.push({\n          text: text,\n          data: data\n        });\n        console.log(\"[SocketClient] Unable to directly send your message since we are not connected. Your message will be buffered and sent later on.\");\n      }\n\n      return this;\n    }\n  }], [{\n    key: \"createDefaultSocketOptions\",\n    value: function createDefaultSocketOptions() {\n      return {\n        channel: 'socket-client',\n        userId: \"user-\".concat(uuid_1.v4()),\n        sessionId: \"session-\".concat(uuid_1.v4()),\n        // connection behaviour\n        expiresIn: null,\n        forceWebsockets: false,\n        disableWebsockets: false,\n        interval: 10000,\n        passthroughIP: null,\n        reconnection: true,\n        reconnectionLimit: 5,\n        // optional brain commands\n        // TODO remove if possible\n        resetFlow: false\n      };\n    }\n  }, {\n    key: \"completeSocketOptions\",\n    value: function completeSocketOptions() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var mergedOptions = Object.assign({}, SocketClient.createDefaultSocketOptions(), options);\n      /**\n       * If no explicit polling or websockets flag was set,\n       * decide implicitly on whether to force websockets\n       * based on the runtime environment.\n       */\n\n      if (!options.forceWebsockets && !options.disableWebsockets) {\n        mergedOptions.forceWebsockets = compatibility_1.shouldForceWebsockets();\n      }\n\n      return mergedOptions;\n    }\n  }]);\n\n  return SocketClient;\n}(events_1.EventEmitter);\n\nexports.SocketClient = SocketClient;","map":{"version":3,"sources":["/Users/aalasseh/Desktop/srFECogngy/node_modules/@cognigy/socket-client/lib/socket-client.js"],"names":["__awaiter","thisArg","_arguments","P","generator","Promise","resolve","reject","fulfilled","value","step","next","e","rejected","result","done","then","apply","Object","defineProperty","exports","events_1","require","SocketIOClient","uuid_1","compatibility_1","SocketClient","socketUrl","socketToken","options","messageBuffer","socketURLToken","socketOptions","completeSocketOptions","reconnectCounter","updateLastUsed","console","log","shouldStopReconnecting","emit","type","reconnectionLimit","length","connected","msg","sendMessage","text","data","socketReconnectInterval","setInterval","registerReconnectionAttempt","isReconnect","connect","error","JSON","stringify","interval","lastUsed","Date","now","socket","expiresIn","parsedUrl","URL","path","pathname","connectOptions","reconnection","upgrade","transports","forceWebsockets","disableWebsockets","sessionId","encodeURIComponent","urlToken","userId","origin","forEach","eventName","on","payload","reply","output","Error","flushMessageBuffer","setupReconnectInterval","clearInterval","disconnect","resetReconnectionCounter","URLToken","channel","source","passthroughIP","resetFlow","push","v4","mergedOptions","assign","createDefaultSocketOptions","shouldForceWebsockets","EventEmitter"],"mappings":"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","sourcesContent":["\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst events_1 = require(\"events\");\nconst SocketIOClient = require(\"socket.io-client\");\nconst uuid_1 = require(\"uuid\");\nconst compatibility_1 = require(\"./helper/compatibility\");\nclass SocketClient extends events_1.EventEmitter {\n    constructor(socketUrl, socketToken, options) {\n        super();\n        this.messageBuffer = [];\n        this.socketUrl = socketUrl;\n        this.socketURLToken = socketToken;\n        this.socketOptions = SocketClient.completeSocketOptions(options);\n        this.reconnectCounter = 0;\n        this.updateLastUsed();\n    }\n    static createDefaultSocketOptions() {\n        return {\n            channel: 'socket-client',\n            userId: `user-${uuid_1.v4()}`,\n            sessionId: `session-${uuid_1.v4()}`,\n            // connection behaviour\n            expiresIn: null,\n            forceWebsockets: false,\n            disableWebsockets: false,\n            interval: 10000,\n            passthroughIP: null,\n            reconnection: true,\n            reconnectionLimit: 5,\n            // optional brain commands\n            // TODO remove if possible\n            resetFlow: false,\n        };\n    }\n    static completeSocketOptions(options = {}) {\n        const mergedOptions = Object.assign({}, SocketClient.createDefaultSocketOptions(), options);\n        /**\n         * If no explicit polling or websockets flag was set,\n         * decide implicitly on whether to force websockets\n         * based on the runtime environment.\n         */\n        if (!options.forceWebsockets && !options.disableWebsockets) {\n            mergedOptions.forceWebsockets = compatibility_1.shouldForceWebsockets();\n        }\n        return mergedOptions;\n    }\n    resetReconnectionCounter() {\n        this.reconnectCounter = 0;\n    }\n    registerReconnectionAttempt() {\n        this.reconnectCounter++;\n        console.log(\"[SocketClient] Trying to reconnect\");\n        if (this.shouldStopReconnecting()) {\n            console.log(`[SocketClient] Reconnection attempts limit reached. Giving up.`);\n            this.emit(\"socket/error\", { type: \"RECONNECTION_LIMIT\" });\n        }\n    }\n    shouldStopReconnecting() {\n        const { reconnectionLimit } = this.socketOptions;\n        return (reconnectionLimit !== 0) && (reconnectionLimit <= this.reconnectCounter);\n    }\n    flushMessageBuffer() {\n        if (this.messageBuffer.length > 0) {\n            if (this.connected) {\n                console.log(`[SocketClient] Starting to send your buffered messages...`);\n                for (let msg of this.messageBuffer) {\n                    this.sendMessage(msg.text, msg.data);\n                }\n                console.log(`[SocketClient] Finished sending ${this.messageBuffer.length} buffered messages.`);\n                this.messageBuffer = [];\n            }\n            else {\n                console.log('[SocketClient] Could not send your buffered messages because we are not connected');\n            }\n        }\n    }\n    setupReconnectInterval() {\n        if (!this.socketReconnectInterval) {\n            this.socketReconnectInterval = setInterval(() => __awaiter(this, void 0, void 0, function* () {\n                if (!this.connected && !this.shouldStopReconnecting()) {\n                    this.registerReconnectionAttempt();\n                    try {\n                        const isReconnect = true;\n                        yield this.connect(isReconnect);\n                        console.log(`[SocketClient] Successfully reconnected.`);\n                    }\n                    catch (err) {\n                        console.error(`[SocketClient] Failed to reconnect, error was: ${JSON.stringify(err)}`);\n                    }\n                    ;\n                }\n            }), this.socketOptions.interval);\n        }\n    }\n    updateLastUsed() {\n        this.lastUsed = Date.now();\n    }\n    get connected() {\n        if (!this.socket)\n            return false;\n        return this.socket.connected;\n    }\n    get expired() {\n        if (this.socketOptions.expiresIn === null)\n            return false;\n        return (Date.now() - this.lastUsed) > this.socketOptions.expiresIn;\n    }\n    connect(isReconnect = false) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const parsedUrl = new URL(this.socketUrl);\n            const path = parsedUrl.pathname && parsedUrl.pathname !== \"/\" ?\n                parsedUrl.pathname + \"/socket.io\" : null;\n            const connectOptions = {\n                path,\n                reconnection: false,\n                upgrade: true,\n                transports: [\"polling\", \"websocket\"]\n            };\n            /**\n             * If websockets are forced or disabled,\n             * change the transport and upgrade flags accordingly.\n             *\n             * In case both options are provided, forcing websockets\n             * wins over disabling websockets.\n             */\n            if (this.socketOptions.forceWebsockets) {\n                connectOptions.transports = [\"websocket\"];\n            }\n            else if (this.socketOptions.disableWebsockets) {\n                connectOptions.transports = [\"polling\"];\n                connectOptions.upgrade = false;\n            }\n            /**\n             * Identify this endpoint to the endpoint for session-to-socket mapping.\n             * Without this, the backend cannot \"take first steps\" because it can't\n             * reach the client!\n             */\n            connectOptions[\"query\"] = {\n                sessionId: encodeURIComponent(this.socketOptions.sessionId),\n                urlToken: encodeURIComponent(this.socketURLToken),\n                userId: encodeURIComponent(this.socketOptions.userId),\n            };\n            const socket = SocketIOClient.connect(parsedUrl.origin, connectOptions);\n            // forward Socket.IO events\n            [\n                'connect',\n                'connect_error',\n                'connect_timeout',\n                'error',\n                'disconnect',\n                'reconnect',\n                'reconnect_attempt',\n                'reconnecting',\n                'reconnect_error',\n                'reconnect_failed',\n                'ping',\n                'pong'\n            ].forEach(eventName => {\n                socket.on(eventName, e => {\n                    this.emit(`socket/${eventName}`, e);\n                });\n            });\n            // pass through basic events\n            socket.on(\"exception\", (error) => this.emit('exception', error));\n            socket.on(\"typingStatus\", (payload) => this.emit('typingStatus', payload));\n            /**\n             * Heads up!\n             *\n             * On v3 environments, we're publishing the \"finalPing\" as an \"output\" event with \"type: finalPing\",\n             * on v4 environments, we're directly publishing the \"finalPing\" as a \"finalPing\" event!\n             */\n            socket.on(\"finalPing\", (reply) => this.emit('finalPing', reply));\n            // decide positive / negative outcome of output based on content\n            socket.on(\"output\", (reply) => {\n                if (reply && reply.type === \"error\") {\n                    return this.emit('error', reply.data.error);\n                }\n                if (reply && reply.type === \"output\") {\n                    let output = reply.data;\n                    this.emit('output', output);\n                }\n                if (reply && reply.type === \"finalPing\") {\n                    this.emit('finalPing', reply.data);\n                }\n            });\n            // return success based on connection status\n            return new Promise((resolve, reject) => {\n                socket.on(\"connect_error\", () => reject(new Error(\"[SocketClient] Error connecting\")));\n                socket.on(\"connect_timeout\", () => reject(new Error(\"[SocketClient] Error connecting\")));\n                socket.on(\"connect\", () => {\n                    console.log(\"[SocketClient] connection established\");\n                    this.socket = socket;\n                    this.flushMessageBuffer();\n                    // if configured, initialize automatic reconnect attempts\n                    if (this.socketOptions.reconnection)\n                        this.setupReconnectInterval();\n                    resolve(this);\n                });\n            });\n        });\n    }\n    disconnect() {\n        clearInterval(this.socketReconnectInterval);\n        this.socketReconnectInterval = null;\n        if (this.socket) {\n            this.socket.disconnect();\n            this.socket = null;\n        }\n        return this;\n    }\n    sendMessage(text, data) {\n        if (this.connected) {\n            this.resetReconnectionCounter();\n            this.updateLastUsed();\n            /* Send the processInput event to the endpoint */\n            this.socket.emit(\"processInput\", {\n                URLToken: this.socketURLToken,\n                userId: this.socketOptions.userId,\n                sessionId: this.socketOptions.sessionId,\n                channel: this.socketOptions.channel,\n                source: \"device\",\n                passthroughIP: this.socketOptions.passthroughIP,\n                resetFlow: !!this.socketOptions.resetFlow,\n                text,\n                data,\n            });\n        }\n        else {\n            // we currently have no connection - could be the case that we lost connection\n            // e.g. because of a server restart of the AI-server. Buffer all incoming\n            // messages - they will be send when the connection was re-established\n            this.messageBuffer.push({\n                text: text,\n                data: data\n            });\n            console.log(`[SocketClient] Unable to directly send your message since we are not connected. Your message will be buffered and sent later on.`);\n        }\n        return this;\n    }\n}\nexports.SocketClient = SocketClient;\n"]},"metadata":{},"sourceType":"script"}